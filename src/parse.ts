import { Err, Ok, type Result } from '@jeppech/results-ts';
import { ValidationError, SchemaErrors, ValidationErrors } from './errors.js';
import type { InferObject, SchemaProperties, SuggestKeys, Validator } from './types.js';

/**
 * Validates a given value for a field, when the list of validators is provided.
 */
export function validate<T>(value: T, field: string, ...validators: Validator<T>[]): T {
  const validation_errors = new ValidationErrors();
  for (const _validate of validators) {
    const err = _validate(value, field);
    if (err) {
      validation_errors.errors.push(err);
    }
  }

  if (validation_errors.errors.length) {
    throw validation_errors;
  }

  return value;
}

/**
 * Match form field names with array notation.
 */
const fd_array_key_rx = new RegExp(/(\w+)\[(.+)?\]/);

export function parse<T extends SchemaProperties>(
  schema: T,
  data: FormData | SuggestKeys<T>,
  skip?: Array<keyof T>,
): Result<InferObject<T>, ValidationError[]> {
  if (data instanceof FormData) {
    return parse_formdata(schema, data, skip);
  }

  if (typeof data === 'string') {
    return parse_object(schema, JSON.parse(data), skip);
  }

  return parse_object(schema, data, skip);
}

/**
 * Parses the given FormData object using the provided schema.
 *
 * A list of fields to skip can be provided. This is useful if a schema is used for creating an object,
 * that has not been given an `id` yet, and the `id` is generated by the server.
 */

export function parse_formdata<T extends SchemaProperties>(
  schema: T,
  fd: FormData,
  skip?: Array<keyof T>,
): Result<InferObject<T>, ValidationError[]> {
  const tmp: Record<string, unknown> = {};
  const parsed: Record<string, unknown> = {};

  for (const key of fd.keys()) {
    const [match, plain_key] = key.match(fd_array_key_rx) || [];
    if (!match) {
      tmp[key] = fd.get(key);
    } else {
      tmp[plain_key] = fd.getAll(key);
    }
  }

  try {
    for (const key in schema) {
      if (skip && skip.includes(key)) {
        continue;
      }

      const valuer = schema[key];

      if (typeof valuer !== 'function') {
        throw new ValidationError(SchemaErrors.valuer_must_be_a_function, valuer, key);
      }

      parsed[key] = valuer(tmp[key] || null, key);
    }
  } catch (err: unknown) {
    if (err instanceof ValidationErrors) {
      return Err(err.errors);
    }

    if (err instanceof ValidationError) {
      return Err([err]);
    }

    return Err([new ValidationError(SchemaErrors.unknown_error, 'unknown', 'unknown', [], err)]);
  }

  return Ok(parsed as InferObject<T>);
}

/**
 * Parses the given object using the provided schema.
 *
 * A list of fields to skip can be provided. This is useful if a schema is used for creating an object,
 * that has not been given an `id` yet, and the `id` is generated by the server.
 */
export function parse_object<T extends SchemaProperties>(
  schema: T,
  data: SuggestKeys<T>,
  skip?: Array<keyof T>,
): Result<InferObject<T>, ValidationError[]> {
  const obj: Record<string, unknown> = {};

  try {
    for (const key in schema) {
      if (skip && skip.includes(key)) {
        continue;
      }

      const valuer = schema[key];

      if (typeof valuer !== 'function') {
        throw new ValidationError(SchemaErrors.valuer_must_be_a_function, valuer, key);
      }

      const value = data[key];

      obj[key] = valuer(value, key);
    }
  } catch (err: unknown) {
    if (err instanceof ValidationErrors) {
      return Err(err.errors);
    }

    if (err instanceof ValidationError) {
      return Err([err]);
    }

    return Err([new ValidationError(SchemaErrors.unknown_error, 'unknown', 'unknown', [], err)]);
  }

  return Ok(obj as InferObject<T>);
}
