import { Err, Ok, type Result } from '@jeppech/results-ts';
import { ValidationError, SchemaErrors, ValidationErrors } from './errors.js';
import type { InferObject, InferValue, SchemaProperties, Validator, Valuer } from './types.js';

/**
 * Define a field with a valuer and any number of optional validators.
 * Valuers can be nested, so fx. a optional field can be defined as: `v.as(v.optional(v.string()))`.
 */
export function as<T extends Valuer>(valuer: T, ...validators: Validator<InferValue<T>>[]) {
  return (value: unknown, field: string) => {
    if (typeof valuer !== 'function') {
      throw new ValidationError(SchemaErrors.valuer_must_be_a_function, valuer, field);
    }

    const parsed = valuer(value, field) as InferValue<T>;

    const validation_errors = new ValidationErrors();
    for (const validate of validators) {
      const err = validate(parsed, field);
      if (err) {
        validation_errors.errors.push(err);
      }
    }

    if (validation_errors.errors.length) {
      throw validation_errors;
    }

    return parsed;
  };
}

/**
 * Match form field names with array notation.
 */
const fd_array_key_rx = new RegExp(/(\w+)\[(.+)?\]/);

/**
 * Parses the given FormData object using the provided schema.
 *
 * A list of fields to skip can be provided. This is useful if a schema is used for creating an object,
 * that has not been given an `id` yet, and the `id` is generated by the server.
 */

export function parse_formdata<T extends SchemaProperties>(
  schema: T,
  fd: FormData,
  skip?: Array<keyof T>,
): Result<InferObject<T>, ValidationError[]> {
  const tmp: Record<string, unknown> = {};
  const parsed: Record<string, unknown> = {};

  for (const key of fd.keys()) {
    const [match, plain_key] = key.match(fd_array_key_rx) || [];
    if (!match) {
      tmp[key] = fd.get(key);
    } else {
      tmp[plain_key] = fd.getAll(key);
    }
  }

  try {
    for (const key in schema) {
      if (skip && skip.includes(key)) {
        continue;
      }

      const valuer = schema[key];

      if (typeof valuer !== 'function') {
        throw new ValidationError(SchemaErrors.valuer_must_be_a_function, valuer, key);
      }

      parsed[key] = valuer(tmp[key] || null, key);
    }
  } catch (err: unknown) {
    if (err instanceof ValidationErrors) {
      return Err(err.errors);
    }

    if (err instanceof ValidationError) {
      return Err([err]);
    }

    return Err([new ValidationError(SchemaErrors.unknown_error, 'unknown', 'unknown', [], err)]);
  }

  return Ok(parsed as InferObject<T>);
}

type SuggestKeys<T extends SchemaProperties> = {
  [K in keyof T]?: unknown;
} & { [k: string]: unknown };

/**
 * Parses the given object using the provided schema.
 *
 * A list of fields to skip can be provided. This is useful if a schema is used for creating an object,
 * that has not been given an `id` yet, and the `id` is generated by the server.
 */
export function parse_object<T extends SchemaProperties>(
  schema: T,
  data: SuggestKeys<T>,
  skip?: Array<keyof T>,
): Result<InferObject<T>, ValidationError[]> {
  const obj: Record<string, unknown> = {};

  try {
    for (const key in schema) {
      if (skip && skip.includes(key)) {
        continue;
      }

      const valuer = schema[key];

      if (typeof valuer !== 'function') {
        throw new ValidationError(SchemaErrors.valuer_must_be_a_function, valuer, key);
      }

      const value = data[key];

      obj[key] = valuer(value, key);
    }
  } catch (err: unknown) {
    if (err instanceof ValidationErrors) {
      return Err(err.errors);
    }

    if (err instanceof ValidationError) {
      return Err([err]);
    }

    return Err([new ValidationError(SchemaErrors.unknown_error, 'unknown', 'unknown', [], err)]);
  }

  return Ok(obj as InferObject<T>);
}
